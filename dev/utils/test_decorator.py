#!/usr/bin/env python

from collections.abc import Callable
from functools import wraps
from inspect import signature


def debug(func):
    @wraps(func)
    def wrapper(*func_args, **func_kwargs):
        print("\n" + "-" * 80 + "\n")
        print(f"Inside {func}")
        print(f"{signature(func)=}")
        print(f"{func_args=}")
        print(f"{func_kwargs=}")
        return func(*func_args, **func_kwargs)

    return wrapper


@debug
def parametrized(decorator):
    @debug
    def generated_decorator(*args, **kwargs):
        @debug
        def wrapper(func):
            return decorator(func, *args, **kwargs)

        return wrapper

    return generated_decorator


@debug
def double(f):
    @debug
    def aux(*xs, **kws):
        return 2 * f(*xs, **kws)

    return aux


@double
@debug
def function(a):
    return 10 + a


@parametrized
def multiply(f, *args, **kwargs):
    print(f"{args=}")
    print(f"{kwargs=}")

    def aux(*xs, **kws):
        if len(args) > 0:
            return args[0] * f(*xs, **kws)
        return f(*xs, **kws)

    return aux


@multiply
def function(a):
    return 10 + a


print(function(3))  # Prints 26


@multiply(3)
def function_again(a):
    return 10 + a


print(function(3))  # Keeps printing 26
print(function_again(3))  # Prints 39, namely 3 * (10 + 3)
print(function(3))  # Prints 26, namely 2 * (10 + 3)


def decorator_factory(argument):
    def decorator(function):
        def wrapper(*args, **kwargs):
            # funny_stuff()
            # something_with_argument(argument)
            result = function(*args, **kwargs)
            # more_funny_stuff()
            return result

        return wrapper

    return decorator


def decorator_with_positionals(__fun__: Callable, a, b, /, c, d, *args, e, f, **kwargs):
    assert callable(__fun__) or __fun__ is None

    def _decorator(func):
        @wraps(func)
        def wrapper(*func_args, **func_kwargs):
            print(f"""
                {a=} reporting in
                {b=} reporting in
                {c=} reporting in
                {d=} reporting in
                {e=} reporting in
                {f=} reporting in
                {args=} reporting in
                {kwargs=} reporting in
                """)
            return func(*func_args, **func_kwargs)

        return wrapper

    return _decorator(__fun__) if callable(__fun__) else _decorator


def decorator_without_positionals(__fun__: Callable, /, c, d, *, e, f):
    assert callable(__fun__) or __fun__ is None

    def _decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            print(f"{x=} reporting in" for x in (c, d, e, f))
            return func(*args, **kwargs)

        return wrapper

    return _decorator(__fun__) if callable(__fun__) else _decorator


def parametrized_decorator(decorator, *meta_args, **meta_kwargs):
    r"""The decorator must have the signature (func, pos_only, kw).

    I.e. the function must be the first argument!
    """
    print(f"{meta_args=}")
    print(f"{meta_kwargs=}")
    # sig = signature(decorator)
    # parameters = sig.parameters.values()
    # num_pos_only_args = len([param for param in parameters if param.kind == Parameter.POSITIONAL_ONLY])
    # if num_pos_only_args == 0:
    #     pass

    def _autogenerated_decorator(*decorator_args, **decorator_kwargs):
        print(f"Entering {decorator=}")
        print(f"{decorator_args=}")
        print(f"{decorator_kwargs=}")
        print("constructing wrapper")

        def wrapper(decorator, *wrapper_args, **wrapper_kwargs):
            print(f"Entering {wrapper=}")
            print(f"{wrapper_args=}")
            print(f"{wrapper_kwargs=}")
            result = decorator(*decorator_args, **decorator_kwargs)
            print(f"Exiting  {decorator=}")

            if len(decorator_args) == 0 and len(decorator_kwargs) == 0:
                pass

            return result

        print("Finished constructing wrapper")

        return wrapper

    return _autogenerated_decorator


@parametrized_decorator
def add(function: Callable[[float], float], bias: float = 0.0):
    @wraps(function)
    def wrapper(*function_args, **function_kwargs):
        print(f"Entering {function=}")
        print(f"{function_args=}")
        print(f"{function_kwargs=}")
        result = function(*function_args, **function_kwargs) + bias
        print(f"Exiting  {function=}")
        return result

    return wrapper


@add(bias=3)
def identity(x):
    return x


def multiplying(f_py=None, factor=1):
    assert callable(f_py) or f_py is None

    def _decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            return factor * func(*args, **kwargs)

        return wrapper

    return _decorator(f_py) if callable(f_py) else _decorator
